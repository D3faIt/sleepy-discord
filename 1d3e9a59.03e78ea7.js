(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{102:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return i})),t.d(n,"toc",(function(){return l})),t.d(n,"default",(function(){return p}));var s=t(3),a=t(7),r=(t(0),t(370)),o={title:"include/sleepy_discord/message.h"},i={unversionedId:"reference/Files/message_8h",id:"reference/Files/message_8h",isDocsHomePage:!1,title:"include/sleepy_discord/message.h",description:"Namespaces",source:"@site/docs/reference/Files/message_8h.md",slug:"/reference/Files/message_8h",permalink:"/sleepy-discord/docs/reference/Files/message_8h",version:"current",sidebar:"Reference",previous:{title:"sleepy_discord/message.cpp",permalink:"/sleepy-discord/docs/reference/Files/message_8cpp"},next:{title:"include/sleepy_discord/message_receiver.h",permalink:"/sleepy-discord/docs/reference/Files/message__receiver_8h"}},l=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Types",id:"types",children:[]},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum InteractionType",id:"enum-interactiontype",children:[]},{value:"enum MentionReplierFlag",id:"enum-mentionreplierflag",children:[]}]},{value:"Source code",id:"source-code",children:[]}],c={toc:l};function p(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(s.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"namespaces"},"Namespaces"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),Object(r.b)("h2",{id:"classes"},"Classes"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null}),Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_emoji"},"SleepyDiscord::Emoji")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_reaction"},"SleepyDiscord::Reaction")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_sticker_pack"},"SleepyDiscord::StickerPack")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_sticker"},"SleepyDiscord::Sticker")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message_reference"},"SleepyDiscord::MessageReference")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message"},"SleepyDiscord::Message")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message_1_1_interaction"},"SleepyDiscord::Message::Interaction")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message_revisions"},"SleepyDiscord::MessageRevisions")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_allow_mentions_parse_helper"},"SleepyDiscord::AllowMentionsParseHelper")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_allowed_mentions"},"SleepyDiscord::AllowedMentions")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_get_default_3_01_allowed_mentions_1_1_mention_replier_flag_01_4"},"SleepyDiscord::GetDefault< AllowedMentions::MentionReplierFlag >")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_get_enum_base_type_3_01_allowed_mentions_1_1_mention_replier_flag_01_4"},"SleepyDiscord::GetEnumBaseType< AllowedMentions::MentionReplierFlag >")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_send_message_params"},"SleepyDiscord::SendMessageParams")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_edit_webhook_params"},"SleepyDiscord::EditWebhookParams")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_web_hook_params"},"SleepyDiscord::WebHookParams")))))),Object(r.b)("h2",{id:"types"},"Types"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null}),Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum int"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/message_8h#enum-interactiontype"},"InteractionType"))," { NONE = 0, Ping = 1, ApplicationCommand = 2}")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum char"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/message_8h#enum-mentionreplierflag"},"MentionReplierFlag"))," { NotSet = -2, DoNotMentionReply = false, MentionReply = true}")))),Object(r.b)("h2",{id:"types-documentation"},"Types Documentation"),Object(r.b)("h3",{id:"enum-interactiontype"},"enum InteractionType"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"NONE"),Object(r.b)("td",{parentName:"tr",align:null},"0"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Ping"),Object(r.b)("td",{parentName:"tr",align:null},"1"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"ApplicationCommand"),Object(r.b)("td",{parentName:"tr",align:null},"2"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h3",{id:"enum-mentionreplierflag"},"enum MentionReplierFlag"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"NotSet"),Object(r.b)("td",{parentName:"tr",align:null},"-2"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"DoNotMentionReply"),Object(r.b)("td",{parentName:"tr",align:null},"false"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"MentionReply"),Object(r.b)("td",{parentName:"tr",align:null},"true"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h2",{id:"source-code"},"Source code"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <tuple>\n#include <memory>\n#include "user.h"\n#include "attachment.h"\n#include "embed.h"\n#include "permissions.h"\n#include "webhook.h"\n#include "discord_object_interface.h"\n#include "snowflake.h"\n#include "channel.h"\n\n// <--- means to add later\n\nnamespace SleepyDiscord {\n    //declear here since message.h is need for slash commands and this enum is needed for messages\n    enum class InteractionType : int {\n        NONE = 0, //made up type\n        Ping = 1,\n        ApplicationCommand = 2,\n    };\n\n    struct Emoji : public IdentifiableDiscordObject<Emoji> {\n    public:\n        ~Emoji();\n        Emoji() = default;\n        //Emoji(const std::string* rawJson);\n        Emoji(const json::Value & rawJSON);\n        Emoji(const nonstd::string_view& json);\n        //Emoji(const json::Values values);\n        std::string name;\n        std::vector<Snowflake<Role>> roles;\n        User user;  //optional\n        bool requireColons = false;\n        bool managed = false;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Emoji::ID           , "id"            , json::NULLABLE_FIELD),\n                json::pair                           (&Emoji::name         , "name"          , json::NULLABLE_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Emoji::roles        , "roles"         , json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::user         , "user"          , json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::requireColons, "require_colons", json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::managed      , "managed"       , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n    \n    struct Reaction : public DiscordObject {\n    public:\n        Reaction() = default;\n        ~Reaction();\n        //Reaction(const std::string * rawJson);\n        Reaction(const json::Value & rawJSON);\n        Reaction(const nonstd::string_view & json);\n        //Reaction(const json::Values values);\n        int count = 0;\n        bool me = false;\n        Emoji emoji;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&Reaction::count, "count", json::REQUIRIED_FIELD),\n                json::pair(&Reaction::me   , "me"   , json::REQUIRIED_FIELD),\n                json::pair(&Reaction::emoji, "emoji", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct StickerPack : public IdentifiableDiscordObject<StickerPack> {\n    public:\n        StickerPack() = default;\n        ~StickerPack();\n        StickerPack(const json::Value & json);\n        StickerPack(const nonstd::string_view & json);\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&StickerPack::ID, "id", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct Sticker : public IdentifiableDiscordObject<Sticker> {\n    public:\n        Sticker() = default;\n        ~Sticker();\n        Sticker(const json::Value & json);\n        Sticker(const nonstd::string_view & json);\n        Snowflake<StickerPack> packID;\n        std::string name;\n        std::string description;\n        std::string tags;\n        enum class Type : int {\n            NONE = 0,\n            PNG = 1,\n            APNG = 2,\n            LOTTIE = 3\n        } format;\n        \n        JSONStructStart\n            std::make_tuple(\n                json::pair                      (&Sticker::ID             , "id"              , json::REQUIRIED_FIELD),\n                json::pair                      (&Sticker::name           , "name"            , json::OPTIONAL_FIELD ),\n                json::pair                      (&Sticker::description    , "description"     , json::OPTIONAL_FIELD ),\n                json::pair                      (&Sticker::tags           , "tags"            , json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper>(&Sticker::format         , "format_type"     , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    //forward declearion\n    class BaseDiscordClient;\n    struct Server;\n    struct Message;\n\n    struct MessageReference {\n    public:\n        MessageReference() = default;\n        ~MessageReference() = default;\n        MessageReference(const json::Value& json);\n        MessageReference(const nonstd::string_view& json);\n        MessageReference(const Message& message);\n\n        Snowflake<Message> messageID;\n        Snowflake<Channel> channelID;\n        Snowflake<Server> serverID;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&MessageReference::messageID, "message_id", json::OPTIONAL_FIELD),\n                json::pair(&MessageReference::channelID, "channel_id", json::OPTIONAL_FIELD),\n                json::pair(&MessageReference::serverID , "guild_id"  , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n        inline const bool empty() const {\n            return messageID.empty() && channelID.empty() && serverID.empty();\n        }\n    };\n\n    struct Message : public IdentifiableDiscordObject<Message> {\n    public:\n        Message() = default;\n        ~Message() = default;\n        //Message(const json::Values values);\n        //Message(const std::string * rawJson);\n        Message(const json::Value& json);\n        Message(const nonstd::string_view& json);\n        //using DiscordObject::DiscordObject;\n        bool startsWith(const std::string& test);\n        std::size_t length();\n        bool isMentioned(Snowflake<User> ID);\n        bool isMentioned(User& _user);\n        Message send(BaseDiscordClient * client);\n        Message reply(BaseDiscordClient * client, std::string message,\n            Embed embed = Embed()\n        );\n\n        Snowflake<Channel> channelID;\n        Snowflake<Server> serverID;\n        User author;\n        ServerMember member;\n        std::string content;\n        std::string timestamp;\n        std::string editedTimestamp;\n        bool tts = false;\n        bool mentionEveryone = false;\n        std::vector<User> mentions;\n        std::vector<Snowflake<User>> mentionRoles;\n        std::vector<Attachment> attachments;\n        std::vector<Embed> embeds;\n        std::vector<Reaction> reactions;\n        bool pinned = false;\n        Snowflake<Webhook> webhookID;\n        enum MessageType {\n            DEFAULT                                =  0,\n            RECIPIENT_ADD                          =  1,\n            RECIPIENT_REMOVE                       =  2,\n            CALL                                   =  3,\n            CHANNEL_NAME_CHANGE                    =  4,\n            CHANNEL_ICON_CHANGE                    =  5,\n            CHANNEL_PINNED_MESSAGE                 =  6,\n            GUILD_MEMBER_JOIN                      =  7,\n            USER_PREMIUM_GUILD_SUBSCRIPTION        =  8,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 =  9,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11,\n            CHANNEL_FOLLOW_ADD                     = 12,\n            GUILD_DISCOVERY_DISQUALIFIED           = 14,\n            GUILD_DISCOVERY_REQUALIFIED            = 15,\n            REPLY                                  = 19\n        } type = DEFAULT;\n        std::vector<Sticker> stickers;\n        MessageReference messageReference;\n        std::shared_ptr<Message> referencedMessage;\n        enum class Flags {\n            DEFAULT                = 0,\n            CROSSPOSTED            = 1 << 0,\n            IS_CROSSPOST           = 1 << 1,\n            SUPPRESS_EMBEDS        = 1 << 2,\n            SOURCE_MESSAGE_DELETED = 1 << 3,\n            URGENT                 = 1 << 4,\n            EPHEMERAL              = 64\n        } flags = Flags::DEFAULT;\n        //interaction\n        struct Interaction : public IdentifiableDiscordObject<Interaction> {\n        public:\n            Interaction() = default;\n            ~Interaction() = default;\n            Interaction(const json::Value& json);\n            Interaction(const nonstd::string_view& json);\n            InteractionType type;\n            std::string name;\n            User user;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair                      (&Interaction::ID       , "id"        , json::REQUIRIED_FIELD),\n                    json::pair<json::EnumTypeHelper>(&Interaction::type     , "type"      , json::REQUIRIED_FIELD),\n                    json::pair                      (&Interaction::name     , "name"      , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Interaction::user     , "user"      , json::OPTIONAL_FIELD)\n                );\n            JSONStructEnd\n        };\n        Snowflake<DiscordObject> applicationID;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Message::ID               , "id"                , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::channelID        , "channel_id"        , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::serverID         , "guild_id"          , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::author           , "author"            , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::content          , "content"           , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::member           , "member"            , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::timestamp        , "timestamp"         , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::editedTimestamp  , "edited_timestamp"  , json::NULLABLE_FIELD ),\n                json::pair                           (&Message::tts              , "tts"               , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::mentionEveryone  , "mention_everyone"  , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::mentions         , "mentions"          , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::mentionRoles     , "mention_roles"     , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::attachments      , "attachments"       , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::embeds           , "embeds"            , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::reactions        , "reactions"         , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::pinned           , "pinned"            , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::webhookID        , "webhook_id"        , json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper     >(&Message::type             , "type"              , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::stickers         , "stickers"          , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::messageReference , "message_reference" , json::OPTIONAL_FIELD ),\n                json::pair<json::SmartPtrTypeHelper >(&Message::referencedMessage, "referenced_message", json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper     >(&Message::flags            , "flags"             , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::applicationID    , "application_id"    , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    inline MessageReference::MessageReference(const Message& message) :\n        messageID(message.ID),\n        channelID(message.channelID),\n        serverID(message.serverID)\n    {}\n\n    struct MessageRevisions {\n        MessageRevisions(const json::Value& json) :\n            messageID(json["id"]), channelID(json["channel_id"]), RevisionsJSON(json)\n        {}\n        inline void applyChanges(Message& outOfDateMessage) {\n            assert(outOfDateMessage.ID == messageID);\n            json::fromJSON(outOfDateMessage, RevisionsJSON);\n        }\n        Snowflake<Message> messageID;\n        Snowflake<Channel> channelID;\n        const json::Value& RevisionsJSON;\n    };\n\n    enum class MentionReplierFlag : char {\n        NotSet = -2,\n        DoNotMentionReply = false,\n        MentionReply = true\n    };\n\n    //allow mentions parse has different behaviors when undefined and empty.\n    //allow mentions parse is also a array. the other values that have this\n    //kind of behavior, where a value makes discord do different thinsg based\n    //on it being defined or not, is that they are a primitive json type or\n    //an object. This one is an array, making it special.\n    template<class Container, template<class...> class TypeHelper>\n    struct AllowMentionsParseHelper :\n        public json::ToContainerFunction<Container, TypeHelper>,\n        public json::FromContainerFunction<Container, TypeHelper>,\n        public json::IsArrayFunction\n    {\n        static inline bool empty(const Container& value) {\n            return value.size() == 1 && value.front().empty();\n        }\n    };\n\n    struct AllowedMentions {\n    public:\n        using ParseValueType = std::string;\n        using ParseContainer = std::vector<std::string>;\n\n        AllowedMentions() = default;\n        ~AllowedMentions() = default;\n        AllowedMentions(int) : parse({}) {}\n        AllowedMentions(const json::Value & json);\n        AllowedMentions(const nonstd::string_view & json);\n        ParseContainer parse = {""};\n        std::vector<Snowflake<Role>> roles;\n        std::vector<Snowflake<User>> users;\n        enum class MentionReplierFlag : char {\n            NotSet = -2,\n            WillNotMentionReply = false,\n            MentionReply = true\n        };\n        MentionReplierFlag repliedUser = MentionReplierFlag::NotSet;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::parse      , "parse"       , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::roles      , "roles"       , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::users      , "users"       , json::OPTIONAL_FIELD),\n                json::pair<json::EnumTypeHelper     >(&AllowedMentions::repliedUser, "replied_user", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n        inline const bool empty() const {\n            return (parse.size() == 1 && parse[0].empty()) && repliedUser == MentionReplierFlag::NotSet;\n        }\n    };\n\n    template<>\n    struct GetDefault<AllowedMentions::MentionReplierFlag> {\n        static inline const AllowedMentions::MentionReplierFlag get() {\n            return AllowedMentions::MentionReplierFlag::NotSet;\n        } \n    };\n\n    template<>\n    struct GetEnumBaseType<AllowedMentions::MentionReplierFlag> {\n        //this makes the json wrapper know to use getBool instead of getInt\n        using Value = bool; \n    };\n\n    struct SendMessageParams : public DiscordObject {\n    public:\n        Snowflake<Channel> channelID;\n        std::string content = {};\n        bool tts = false;\n        Embed embed = Embed::Flag::INVALID_EMBED;\n        AllowedMentions allowedMentions;\n        MessageReference messageReference;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&SendMessageParams::content         , "content"          , json::REQUIRIED_FIELD),\n                json::pair(&SendMessageParams::tts             , "tts"              , json::OPTIONAL_FIELD ),\n                json::pair(&SendMessageParams::embed           , "embed"            , json::OPTIONAL_FIELD ),\n                json::pair(&SendMessageParams::allowedMentions , "allowed_mentions" , json::OPTIONAL_FIELD ),\n                json::pair(&SendMessageParams::messageReference, "message_reference", json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    struct EditWebhookParams : public DiscordObject {\n    public:\n        std::string content;\n        std::vector<Embed> embeds;\n        AllowedMentions allowedMentions;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&EditWebhookParams::content        , "content"         , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&EditWebhookParams::embeds         , "embeds"          , json::OPTIONAL_FIELD),\n                json::pair                           (&EditWebhookParams::allowedMentions, "allowed_mentions", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct WebHookParams : public EditWebhookParams {\n    public:\n        std::string username;\n        std::string avatarURL;\n        bool tts = false;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&WebHookParams::content         , "content"          , json::OPTIONAL_FIELD ),\n                json::pair                           (&WebHookParams::username        , "username"         , json::OPTIONAL_FIELD ),\n                json::pair                           (&WebHookParams::avatarURL       , "avatar_url"       , json::OPTIONAL_FIELD ),\n                json::pair                           (&WebHookParams::tts             , "tts"              , json::OPTIONAL_FIELD ),\n                json::pair<json::ContainerTypeHelper>(&WebHookParams::embeds          , "embeds"           , json::OPTIONAL_FIELD ),\n                json::pair                           (&WebHookParams::allowedMentions , "allowed_mentions" , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n}\n')),Object(r.b)("hr",null),Object(r.b)("p",null,"Updated on 13 May 2021 at 01:04:54 UTC"))}p.isMDXComponent=!0},370:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return u}));var s=t(0),a=t.n(s);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,s,a=function(e,n){if(null==e)return{};var t,s,a={},r=Object.keys(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=a.a.createContext({}),p=function(e){var n=a.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=p(e.components);return a.a.createElement(c.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},m=a.a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=s,u=d["".concat(o,".").concat(m)]||d[m]||b[m]||r;return t?a.a.createElement(u,i(i({ref:n},c),{},{components:t})):a.a.createElement(u,i({ref:n},c))}));function u(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,o=new Array(r);o[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var c=2;c<r;c++)o[c]=t[c];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);