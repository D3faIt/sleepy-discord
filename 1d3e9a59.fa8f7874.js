(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{107:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return l})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return p}));var a=t(3),s=t(7),r=(t(0),t(393)),o={title:"include/sleepy_discord/message.h"},l={unversionedId:"reference/Files/message_8h",id:"reference/Files/message_8h",isDocsHomePage:!1,title:"include/sleepy_discord/message.h",description:"Namespaces",source:"@site/docs/reference/Files/message_8h.md",slug:"/reference/Files/message_8h",permalink:"/sleepy-discord/docs/reference/Files/message_8h",version:"current",sidebar:"Reference",previous:{title:"sleepy_discord/message.cpp",permalink:"/sleepy-discord/docs/reference/Files/message_8cpp"},next:{title:"include/sleepy_discord/message_receiver.h",permalink:"/sleepy-discord/docs/reference/Files/message__receiver_8h"}},c=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Types",id:"types",children:[]},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum InteractionType",id:"enum-interactiontype",children:[]},{value:"enum ComponentType",id:"enum-componenttype",children:[]},{value:"enum ButtonStyle",id:"enum-buttonstyle",children:[]},{value:"enum MentionReplierFlag",id:"enum-mentionreplierflag",children:[]}]},{value:"Source code",id:"source-code",children:[]}],i={toc:c};function p(e){var n=e.components,t=Object(s.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},i,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"namespaces"},"Namespaces"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord_1_1json"},"SleepyDiscord::json")))))),Object(r.b)("h2",{id:"classes"},"Classes"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null}),Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_emoji"},"SleepyDiscord::Emoji")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_reaction"},"SleepyDiscord::Reaction")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_base_component"},"SleepyDiscord::BaseComponent")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_raw_component"},"SleepyDiscord::RawComponent")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_component_temp"},"SleepyDiscord::ComponentTemp")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_action_row"},"SleepyDiscord::ActionRow")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_button"},"SleepyDiscord::Button")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_select_menu"},"SleepyDiscord::SelectMenu")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_select_menu_1_1_option"},"SleepyDiscord::SelectMenu::Option")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01std_1_1shared__ptr_3_01_base_component_01_4_01_4"},"SleepyDiscord::json::ClassTypeHelper< std::shared_ptr< BaseComponent > >")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_sticker_pack"},"SleepyDiscord::StickerPack")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_sticker"},"SleepyDiscord::Sticker")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message_reference"},"SleepyDiscord::MessageReference")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message"},"SleepyDiscord::Message")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message_1_1_interaction"},"SleepyDiscord::Message::Interaction")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message_revisions"},"SleepyDiscord::MessageRevisions")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_allow_mentions_parse_helper"},"SleepyDiscord::AllowMentionsParseHelper")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_allowed_mentions"},"SleepyDiscord::AllowedMentions")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_get_default_3_01_allowed_mentions_1_1_mention_replier_flag_01_4"},"SleepyDiscord::GetDefault< AllowedMentions::MentionReplierFlag >")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_get_enum_base_type_3_01_allowed_mentions_1_1_mention_replier_flag_01_4"},"SleepyDiscord::GetEnumBaseType< AllowedMentions::MentionReplierFlag >")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message_params"},"SleepyDiscord::MessageParams")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_send_message_params"},"SleepyDiscord::SendMessageParams")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_edit_message_params"},"SleepyDiscord::EditMessageParams")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_edit_webhook_params"},"SleepyDiscord::EditWebhookParams")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_web_hook_params"},"SleepyDiscord::WebHookParams")))))),Object(r.b)("h2",{id:"types"},"Types"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null}),Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum int"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/message_8h#enum-interactiontype"},"InteractionType"))," { NONE = 0, Ping = 1, ApplicationCommand = 2, MessageComponent = 3, ApplicationCommandAutocomplete = 4}")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/message_8h#enum-componenttype"},"ComponentType"))," { NONE = 0, ActionRow = 1, Button = 2, SelectMenu = 3}")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/message_8h#enum-buttonstyle"},"ButtonStyle"))," { NONE = 0, Primary = 1, Secondary = 2, Success = 3, Danger = 4, Link = 5, DefaultStyle = NONE}")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum char"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/message_8h#enum-mentionreplierflag"},"MentionReplierFlag"))," { NotSet = -2, DoNotMentionReply = false, MentionReply = true}")))),Object(r.b)("h2",{id:"types-documentation"},"Types Documentation"),Object(r.b)("h3",{id:"enum-interactiontype"},"enum InteractionType"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"NONE"),Object(r.b)("td",{parentName:"tr",align:null},"0"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Ping"),Object(r.b)("td",{parentName:"tr",align:null},"1"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"ApplicationCommand"),Object(r.b)("td",{parentName:"tr",align:null},"2"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"MessageComponent"),Object(r.b)("td",{parentName:"tr",align:null},"3"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"ApplicationCommandAutocomplete"),Object(r.b)("td",{parentName:"tr",align:null},"4"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h3",{id:"enum-componenttype"},"enum ComponentType"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"NONE"),Object(r.b)("td",{parentName:"tr",align:null},"0"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"ActionRow"),Object(r.b)("td",{parentName:"tr",align:null},"1"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Button"),Object(r.b)("td",{parentName:"tr",align:null},"2"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SelectMenu"),Object(r.b)("td",{parentName:"tr",align:null},"3"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h3",{id:"enum-buttonstyle"},"enum ButtonStyle"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"NONE"),Object(r.b)("td",{parentName:"tr",align:null},"0"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Primary"),Object(r.b)("td",{parentName:"tr",align:null},"1"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Secondary"),Object(r.b)("td",{parentName:"tr",align:null},"2"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Success"),Object(r.b)("td",{parentName:"tr",align:null},"3"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Danger"),Object(r.b)("td",{parentName:"tr",align:null},"4"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Link"),Object(r.b)("td",{parentName:"tr",align:null},"5"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"DefaultStyle"),Object(r.b)("td",{parentName:"tr",align:null},"NONE"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h3",{id:"enum-mentionreplierflag"},"enum MentionReplierFlag"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"NotSet"),Object(r.b)("td",{parentName:"tr",align:null},"-2"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"DoNotMentionReply"),Object(r.b)("td",{parentName:"tr",align:null},"false"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"MentionReply"),Object(r.b)("td",{parentName:"tr",align:null},"true"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h2",{id:"source-code"},"Source code"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <tuple>\n#include <memory>\n#include "user.h"\n#include "attachment.h"\n#include "embed.h"\n#include "permissions.h"\n#include "webhook.h"\n#include "discord_object_interface.h"\n#include "snowflake.h"\n#include "channel.h"\n\n// <--- means to add later\n\nnamespace SleepyDiscord {\n    //declear here since message.h is need for slash commands and this enum is needed for messages\n    enum class InteractionType : int {\n        NONE = 0, //made up type\n        Ping = 1,\n        ApplicationCommand = 2,\n        MessageComponent = 3,\n        ApplicationCommandAutocomplete = 4\n    };\n\n    struct Emoji : public IdentifiableDiscordObject<Emoji> {\n    public:\n        ~Emoji();\n        Emoji() = default;\n        //Emoji(const std::string* rawJson);\n        Emoji(const json::Value & rawJSON);\n        Emoji(const nonstd::string_view& json) :\n            Emoji(json::fromJSON<Emoji>(json)) {}\n        //Emoji(const json::Values values);\n        std::string name;\n        std::vector<Snowflake<Role>> roles;\n        User user;  //optional\n        bool requireColons = false;\n        bool managed = false;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Emoji::ID           , "id"            , json::NULLABLE_FIELD),\n                json::pair                           (&Emoji::name         , "name"          , json::NULLABLE_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Emoji::roles        , "roles"         , json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::user         , "user"          , json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::requireColons, "require_colons", json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::managed      , "managed"       , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n    \n    struct Reaction : public DiscordObject {\n    public:\n        Reaction() = default;\n        ~Reaction();\n        //Reaction(const std::string * rawJson);\n        Reaction(const json::Value & rawJSON);\n        Reaction(const nonstd::string_view& json) :\n            Reaction(json::fromJSON<Reaction>(json)) {}\n        //Reaction(const json::Values values);\n        int count = 0;\n        bool me = false;\n        Emoji emoji;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&Reaction::count, "count", json::REQUIRIED_FIELD),\n                json::pair(&Reaction::me   , "me"   , json::REQUIRIED_FIELD),\n                json::pair(&Reaction::emoji, "emoji", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    enum class ComponentType {\n        NONE = 0, //made up by the library\n        ActionRow = 1,\n        Button = 2,\n        SelectMenu = 3,\n    };\n\n    struct BaseComponent : public DiscordObject {\n        using Type = ComponentType;\n        BaseComponent() = delete;\n        BaseComponent(Type _type) : type(_type) {}\n        ~BaseComponent() = default;\n\n        inline const ComponentType getType() const { return type; }\n\n    protected:\n        Type type;\n    };\n\n    struct RawComponent : public BaseComponent {\n        using JSONTypeHelper = json::ClassTypeHelper<json::Value>;\n\n        RawComponent(BaseComponent base, json::Value& rawJSON) : BaseComponent(std::move(base)) {\n            data = JSONTypeHelper::toType(rawJSON);\n        }\n        RawComponent(json::Value& rawJSON) : RawComponent(BaseComponent{static_cast<ComponentType>(rawJSON["type"].GetInt())}, rawJSON) {}\n        RawComponent(const nonstd::string_view& json) :\n            RawComponent(json::fromJSON<RawComponent>(json)) {}\n        RawComponent(const RawComponent& origin) : BaseComponent(origin.type), data(json::copy(origin.data)) {}\n\n        inline json::Value serialize(typename json::Value::AllocatorType& alloc) const {\n            return JSONTypeHelper::fromType(data, alloc);\n        }\n\n        inline const bool empty() const { return JSONTypeHelper::empty(data); }\n\n        static inline const bool isType(const typename json::Value& value) {\n            return value.IsObject() && value.FindMember("type") != value.MemberEnd();\n        }\n\n        json::Value data;\n    };\n\n    template<class Child>\n    struct ComponentTemp : public BaseComponent {\n        ComponentTemp() : BaseComponent(Child::componentType) {}\n        ~ComponentTemp() = default;\n\n        inline operator json::Value() {\n            return json::toJSON(static_cast<Child&>(*this));\n        }\n\n        inline operator RawComponent() {\n            return RawComponent{ Child::componentType, operator json::Value() };\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair<json::EnumTypeHelper>(&Child::type, "type", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ActionRow : public ComponentTemp<ActionRow> {\n        ActionRow() = default;\n        ~ActionRow() = default;\n        ActionRow(json::Value& json);\n        ActionRow(const nonstd::string_view& json) :\n            ActionRow(json::fromJSON<ActionRow>(json)) {}\n        static const ComponentType componentType = ComponentType::ActionRow;\n\n        std::vector<std::shared_ptr<BaseComponent>> components;\n\n        JSONStructStart\n            std::tuple_cat(\n                ComponentTemp<ActionRow>::JSONStruct,\n                std::make_tuple(\n                    json::pair<json::ContainerTypeHelper>(&ActionRow::components, "components", json::OPTIONAL_FIELD)\n                )\n            );\n        JSONStructEnd\n    };\n\n    enum class ButtonStyle {\n        NONE = 0,\n        Primary = 1,\n        Secondary = 2,\n        Success = 3,\n        Danger = 4,\n        Link = 5,\n        DefaultStyle = NONE, //made up for the library to handle null style\n    };\n\n    struct Button : public ComponentTemp<Button> {\n        Button() = default;\n        ~Button() = default;\n        Button(const json::Value& json);\n        Button(const nonstd::string_view& json) :\n            Button(json::fromJSON<Button>(json)) {}\n        static const ComponentType componentType = ComponentType::Button;\n\n        ButtonStyle style;\n        std::string label;\n        Emoji emoji;\n        std::string customID;\n        std::string url;\n        bool disabled = false;\n\n        JSONStructStart\n            std::tuple_cat(\n                ComponentTemp<Button>::JSONStruct,\n                std::make_tuple(\n                    json::pair<json::EnumTypeHelper>(&Button::style   , "style"    , json::REQUIRIED_FIELD),\n                    json::pair                      (&Button::label   , "label"    , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Button::emoji   , "emoji"    , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Button::customID, "custom_id", json::OPTIONAL_FIELD ),\n                    json::pair                      (&Button::url     , "url"      , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Button::disabled, "disabled" , json::OPTIONAL_FIELD )\n                )\n            );\n        JSONStructEnd\n    };\n\n    struct SelectMenu : public ComponentTemp<SelectMenu> {\n        SelectMenu() = default;\n        ~SelectMenu() = default;\n        SelectMenu(const json::Value& json);\n        SelectMenu(const nonstd::string_view& json) :\n            SelectMenu(json::fromJSON<SelectMenu>(json)) {}\n        static const ComponentType componentType = ComponentType::SelectMenu;\n\n        struct Option : public DiscordObject {\n            Option() = default;\n            ~Option() = default;\n            Option(const json::Value & rawJSON);\n            Option(const nonstd::string_view& json) :\n                SelectMenu::Option(json::fromJSON<SelectMenu::Option>(json)) {}\n\n            std::string label;\n            std::string value;\n            std::string description;\n            Emoji emoji;\n            bool isDefault = false;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair(&Option::label      , "label"      , json::REQUIRIED_FIELD),\n                    json::pair(&Option::value      , "value"      , json::REQUIRIED_FIELD),\n                    json::pair(&Option::description, "description", json::OPTIONAL_FIELD ),\n                    json::pair(&Option::emoji      , "emoji"      , json::OPTIONAL_FIELD ),\n                    json::pair(&Option::isDefault  , "default"    , json::OPTIONAL_FIELD )\n                );\n            JSONStructEnd\n        };\n\n        std::string customID;\n        std::vector<Option> options;\n        std::string placeholder;\n        int minValues = 1;\n        int maxValues = 1;\n        bool disabled = false;\n\n        JSONStructStart\n            std::tuple_cat(\n                ComponentTemp<SelectMenu>::JSONStruct,\n                std::make_tuple(\n                    json::pair                           (&SelectMenu::customID   , "custom_id"  , json::REQUIRIED_FIELD),\n                    json::pair<json::ContainerTypeHelper>(&SelectMenu::options    , "options"    , json::REQUIRIED_FIELD),\n                    json::pair                           (&SelectMenu::placeholder, "placeholder", json::OPTIONAL_FIELD ),\n                    json::pair<                        1>(&SelectMenu::minValues  , "min_values" , json::OPTIONAL_FIELD ),\n                    json::pair<                        1>(&SelectMenu::maxValues  , "max_values" , json::OPTIONAL_FIELD ),\n                    json::pair                           (&SelectMenu::disabled   , "disabled"   , json::OPTIONAL_FIELD )\n                )\n            );\n        JSONStructEnd\n    };\n\n    namespace json {\n        template<>\n        struct ClassTypeHelper<std::shared_ptr<BaseComponent>> {\n            using Base = BaseComponent;\n            using Type = std::shared_ptr<BaseComponent>;\n\n            static inline Type toType(json::Value& value) {\n                const ComponentType type = static_cast<ComponentType>(value["type"].GetInt());\n                switch (type) {\n                default:\n                    return std::make_shared<RawComponent>(Base{ type }, value);\n                case ComponentType::ActionRow:\n                    return std::make_shared<ActionRow>(value);\n                case ComponentType::Button:\n                    return std::make_shared<Button>(value);\n                case ComponentType::SelectMenu:\n                    return std::make_shared<SelectMenu>(value);\n                }\n            }\n            static inline json::Value fromType(const Type& value, json::Value::AllocatorType& allocator) {\n                const ComponentType type = value->getType();\n                switch (type) {\n                default:\n                    return std::static_pointer_cast<RawComponent>(value)->serialize(allocator);\n                case ComponentType::ActionRow:\n                    return json::ClassTypeHelper<ActionRow>::fromType(*std::static_pointer_cast<ActionRow>(value), allocator);\n                case ComponentType::Button:\n                    return json::ClassTypeHelper<Button>::fromType(*std::static_pointer_cast<Button>(value), allocator);\n                case ComponentType::SelectMenu:\n                    return json::ClassTypeHelper<SelectMenu>::fromType(*std::static_pointer_cast<SelectMenu>(value), allocator);\n                }\n            }\n            static inline bool empty(const Type& value) {\n                return json::SmartPtrTypeHelper<std::shared_ptr<BaseComponent>, json::ClassTypeHelper>::empty(value);\n            }\n            static inline bool isType(const json::Value& value) {\n                return value.IsObject() && value.FindMember("type") != value.MemberEnd();\n            }\n        };\n    }\n\n    struct StickerPack : public IdentifiableDiscordObject<StickerPack> {\n    public:\n        StickerPack() = default;\n        ~StickerPack();\n        StickerPack(const json::Value & json);\n        StickerPack(const nonstd::string_view& json) :\n            StickerPack(json::fromJSON<StickerPack>(json)) {}\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&StickerPack::ID, "id", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct Sticker : public IdentifiableDiscordObject<Sticker> {\n    public:\n        Sticker() = default;\n        ~Sticker();\n        Sticker(const json::Value & json);\n        Sticker(const nonstd::string_view & json);\n        Snowflake<StickerPack> packID;\n        std::string name;\n        std::string description;\n        std::string tags;\n        enum class Type : int {\n            NONE = 0,\n            PNG = 1,\n            APNG = 2,\n            LOTTIE = 3\n        } format;\n        \n        JSONStructStart\n            std::make_tuple(\n                json::pair                      (&Sticker::ID             , "id"              , json::REQUIRIED_FIELD),\n                json::pair                      (&Sticker::name           , "name"            , json::OPTIONAL_FIELD ),\n                json::pair                      (&Sticker::description    , "description"     , json::OPTIONAL_FIELD ),\n                json::pair                      (&Sticker::tags           , "tags"            , json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper>(&Sticker::format         , "format_type"     , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    //forward declearion\n    class BaseDiscordClient;\n    struct Server;\n    struct Message;\n\n    struct MessageReference {\n    public:\n        MessageReference() = default;\n        ~MessageReference() = default;\n        MessageReference(const json::Value& json);\n        MessageReference(const nonstd::string_view& json) :\n            MessageReference(json::fromJSON<MessageReference>(json)) {}\n        MessageReference(const Message& message);\n\n        Snowflake<Message> messageID;\n        Snowflake<Channel> channelID;\n        Snowflake<Server> serverID;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&MessageReference::messageID, "message_id", json::OPTIONAL_FIELD),\n                json::pair(&MessageReference::channelID, "channel_id", json::OPTIONAL_FIELD),\n                json::pair(&MessageReference::serverID , "guild_id"  , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n        inline const bool empty() const {\n            return messageID.empty() && channelID.empty() && serverID.empty();\n        }\n    };\n\n    struct Message : public IdentifiableDiscordObject<Message> {\n    public:\n        Message() = default;\n        ~Message() = default;\n        Message(json::Value& json);\n        Message(const nonstd::string_view& json) :\n            Message(json::fromJSON<Message>(json)){}\n        bool startsWith(const std::string& test);\n        std::size_t length();\n        bool isMentioned(Snowflake<User> ID);\n        bool isMentioned(User& _user);\n        Message send(BaseDiscordClient * client);\n        Message reply(BaseDiscordClient * client, std::string message,\n            Embed embed = Embed()\n        );\n\n        Snowflake<Channel> channelID;\n        Snowflake<Server> serverID;\n        User author;\n        ServerMember member;\n        std::string content;\n        std::string timestamp;\n        std::string editedTimestamp;\n        bool tts = false;\n        bool mentionEveryone = false;\n        std::vector<User> mentions;\n        std::vector<Snowflake<User>> mentionRoles;\n        std::vector<Attachment> attachments;\n        std::vector<Embed> embeds;\n        std::vector<Reaction> reactions;\n        bool pinned = false;\n        Snowflake<Webhook> webhookID;\n        enum MessageType {\n            DEFAULT                                =  0,\n            RECIPIENT_ADD                          =  1,\n            RECIPIENT_REMOVE                       =  2,\n            CALL                                   =  3,\n            CHANNEL_NAME_CHANGE                    =  4,\n            CHANNEL_ICON_CHANGE                    =  5,\n            CHANNEL_PINNED_MESSAGE                 =  6,\n            GUILD_MEMBER_JOIN                      =  7,\n            USER_PREMIUM_GUILD_SUBSCRIPTION        =  8,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 =  9,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11,\n            CHANNEL_FOLLOW_ADD                     = 12,\n            GUILD_DISCOVERY_DISQUALIFIED           = 14,\n            GUILD_DISCOVERY_REQUALIFIED            = 15,\n            REPLY                                  = 19\n        } type = DEFAULT;\n        std::vector<Sticker> stickers;\n        MessageReference messageReference;\n        std::shared_ptr<Message> referencedMessage;\n        enum class Flags {\n            DEFAULT                = 0,\n            CROSSPOSTED            = 1 << 0,\n            IS_CROSSPOST           = 1 << 1,\n            SUPPRESS_EMBEDS        = 1 << 2,\n            SOURCE_MESSAGE_DELETED = 1 << 3,\n            URGENT                 = 1 << 4,\n            EPHEMERAL              = 64\n        } flags = Flags::DEFAULT;\n        //interaction\n        struct Interaction : public IdentifiableDiscordObject<Interaction> {\n        public:\n            Interaction() = default;\n            ~Interaction() = default;\n            Interaction(const json::Value& json);\n            Interaction(const nonstd::string_view& json) :\n                Interaction(json::fromJSON<Message::Interaction>(json)) {}\n            InteractionType type = InteractionType::NONE;\n            std::string name;\n            User user;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair                      (&Interaction::ID       , "id"        , json::REQUIRIED_FIELD),\n                    json::pair<json::EnumTypeHelper>(&Interaction::type     , "type"      , json::REQUIRIED_FIELD),\n                    json::pair                      (&Interaction::name     , "name"      , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Interaction::user     , "user"      , json::OPTIONAL_FIELD )\n                );\n            JSONStructEnd\n        };\n        Interaction interaction;\n        Snowflake<DiscordObject> applicationID;\n        //components\n        std::vector<std::shared_ptr<BaseComponent>> components;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Message::ID               , "id"                , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::channelID        , "channel_id"        , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::serverID         , "guild_id"          , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::author           , "author"            , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::content          , "content"           , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::member           , "member"            , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::timestamp        , "timestamp"         , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::editedTimestamp  , "edited_timestamp"  , json::NULLABLE_FIELD ),\n                json::pair                           (&Message::tts              , "tts"               , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::mentionEveryone  , "mention_everyone"  , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::mentions         , "mentions"          , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::mentionRoles     , "mention_roles"     , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::attachments      , "attachments"       , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::embeds           , "embeds"            , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::reactions        , "reactions"         , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::pinned           , "pinned"            , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::webhookID        , "webhook_id"        , json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper     >(&Message::type             , "type"              , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::stickers         , "stickers"          , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::messageReference , "message_reference" , json::OPTIONAL_FIELD ),\n                json::pair<json::SmartPtrTypeHelper >(&Message::referencedMessage, "referenced_message", json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper     >(&Message::flags            , "flags"             , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::interaction      , "interaction"       , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::applicationID    , "application_id"    , json::OPTIONAL_FIELD ),\n                json::pair<json::ContainerTypeHelper>(&Message::components       , "components"        , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    inline MessageReference::MessageReference(const Message& message) :\n        messageID(message.ID),\n        channelID(message.channelID),\n        serverID(message.serverID)\n    {}\n\n    struct MessageRevisions {\n        MessageRevisions(json::Value& json) :\n            messageID(json["id"]), channelID(json["channel_id"]), RevisionsJSON(json)\n        {}\n        inline void applyChanges(Message& outOfDateMessage) {\n            assert(outOfDateMessage.ID == messageID);\n            json::fromJSON(outOfDateMessage, RevisionsJSON);\n        }\n        Snowflake<Message> messageID;\n        Snowflake<Channel> channelID;\n        json::Value& RevisionsJSON;\n    };\n\n    enum class MentionReplierFlag : char {\n        NotSet = -2,\n        DoNotMentionReply = false,\n        MentionReply = true\n    };\n\n    //allow mentions parse has different behaviors when undefined and empty.\n    //allow mentions parse is also a array. the other values that have this\n    //kind of behavior, where a value makes discord do different thinsg based\n    //on it being defined or not, is that they are a primitive json type or\n    //an object. This one is an array, making it special.\n    template<class Container, template<class...> class TypeHelper>\n    struct AllowMentionsParseHelper :\n        public json::ToContainerFunction<Container, TypeHelper>,\n        public json::FromContainerFunction<Container, TypeHelper>,\n        public json::IsArrayFunction\n    {\n        static inline bool empty(const Container& value) {\n            return value.size() == 1 && value.front().empty();\n        }\n    };\n\n    struct AllowedMentions {\n    public:\n        using ParseValueType = std::string;\n        using ParseContainer = std::vector<std::string>;\n\n        AllowedMentions() = default;\n        ~AllowedMentions() = default;\n        AllowedMentions(int) : parse({}) {}\n        AllowedMentions(const json::Value & json);\n        AllowedMentions(const nonstd::string_view& json) :\n            AllowedMentions(json::fromJSON<AllowedMentions>(json)) {}\n        ParseContainer parse = {""};\n        std::vector<Snowflake<Role>> roles;\n        std::vector<Snowflake<User>> users;\n        enum class MentionReplierFlag : char {\n            NotSet = -2,\n            WillNotMentionReply = false,\n            MentionReply = true\n        };\n        MentionReplierFlag repliedUser = MentionReplierFlag::NotSet;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::parse      , "parse"       , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::roles      , "roles"       , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::users      , "users"       , json::OPTIONAL_FIELD),\n                json::pair<json::EnumTypeHelper     >(&AllowedMentions::repliedUser, "replied_user", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n        inline const bool empty() const {\n            return (parse.size() == 1 && parse[0].empty()) && repliedUser == MentionReplierFlag::NotSet;\n        }\n    };\n\n    template<>\n    struct GetDefault<AllowedMentions::MentionReplierFlag> {\n        static inline const AllowedMentions::MentionReplierFlag get() {\n            return AllowedMentions::MentionReplierFlag::NotSet;\n        } \n    };\n\n    template<>\n    struct GetEnumBaseType<AllowedMentions::MentionReplierFlag> {\n        //this makes the json wrapper know to use getBool instead of getInt\n        using Value = bool; \n    };\n\n    template<class Type>\n    struct MessageParams : public DiscordObject {\n        Snowflake<Channel> channelID;\n        std::string content = {};\n        Embed embed = Embed::Flag::INVALID_EMBED;\n        AllowedMentions allowedMentions;\n        std::vector<std::shared_ptr<BaseComponent>> components;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Type::content        , "content"         , json::OPTIONAL_FIELD),\n                json::pair                           (&Type::embed          , "embed"           , json::OPTIONAL_FIELD),\n                json::pair                           (&Type::allowedMentions, "allowed_mentions", json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Type::components     , "components"      , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct SendMessageParams : MessageParams<SendMessageParams> {\n    public:\n        bool tts = false;\n        MessageReference messageReference;\n\n        JSONStructStart\n            std::tuple_cat(\n                MessageParams<SendMessageParams>::JSONStruct,\n                std::make_tuple(\n                    json::pair(&SendMessageParams::tts             , "tts"              , json::OPTIONAL_FIELD ),\n                    json::pair(&SendMessageParams::messageReference, "message_reference", json::OPTIONAL_FIELD )\n                )\n            );\n        JSONStructEnd\n    };\n\n    struct EditMessageParams : MessageParams<EditMessageParams> {\n    public:\n        Snowflake<Message> messageID;\n        Message::Flags flags = Message::Flags::DEFAULT;\n        std::vector<Attachment> attachments;\n\n        JSONStructStart\n            std::tuple_cat(\n                MessageParams<EditMessageParams>::JSONStruct,\n                std::make_tuple(\n                    json::pair<json::EnumTypeHelper     >(&EditMessageParams::flags      , "flags"      , json::OPTIONAL_FIELD),\n                    json::pair<json::ContainerTypeHelper>(&EditMessageParams::attachments, "attachments", json::OPTIONAL_FIELD)\n                )\n            );\n        JSONStructEnd\n    };\n\n    struct EditWebhookParams : public DiscordObject {\n    public:\n        std::string content;\n        std::vector<Embed> embeds;\n        AllowedMentions allowedMentions;\n        std::vector<std::shared_ptr<BaseComponent>> components;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&EditWebhookParams::content        , "content"         , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&EditWebhookParams::embeds         , "embeds"          , json::OPTIONAL_FIELD),\n                json::pair                           (&EditWebhookParams::allowedMentions, "allowed_mentions", json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&EditWebhookParams::components     , "components"      , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct WebHookParams : public EditWebhookParams {\n    public:\n        std::string username;\n        std::string avatarURL;\n        bool tts = false;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&WebHookParams::content         , "content"          , json::OPTIONAL_FIELD),\n                json::pair                           (&WebHookParams::username        , "username"         , json::OPTIONAL_FIELD),\n                json::pair                           (&WebHookParams::avatarURL       , "avatar_url"       , json::OPTIONAL_FIELD),\n                json::pair                           (&WebHookParams::tts             , "tts"              , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&WebHookParams::embeds          , "embeds"           , json::OPTIONAL_FIELD),\n                json::pair                           (&WebHookParams::allowedMentions , "allowed_mentions" , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&WebHookParams::components      , "components"       , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n}\n')),Object(r.b)("hr",null),Object(r.b)("p",null,"Updated on 26 November 2021 at 18:07:04 UTC"))}p.isMDXComponent=!0},393:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return u}));var a=t(0),s=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var i=s.a.createContext({}),p=function(e){var n=s.a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},b=function(e){var n=p(e.components);return s.a.createElement(i.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return s.a.createElement(s.a.Fragment,{},n)}},m=s.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,i=c(e,["components","mdxType","originalType","parentName"]),b=p(t),m=a,u=b["".concat(o,".").concat(m)]||b[m]||d[m]||r;return t?s.a.createElement(u,l(l({ref:n},i),{},{components:t})):s.a.createElement(u,l({ref:n},i))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=m;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var i=2;i<r;i++)o[i]=t[i];return s.a.createElement.apply(null,o)}return s.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);