(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{125:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return a})),t.d(n,"metadata",(function(){return d})),t.d(n,"toc",(function(){return i})),t.d(n,"default",(function(){return l}));var r=t(3),o=t(7),s=(t(0),t(393)),a={title:"include/sleepy_discord/embed.h"},d={unversionedId:"reference/Files/embed_8h",id:"reference/Files/embed_8h",isDocsHomePage:!1,title:"include/sleepy_discord/embed.h",description:"Namespaces",source:"@site/docs/reference/Files/embed_8h.md",slug:"/reference/Files/embed_8h",permalink:"/sleepy-discord/docs/reference/Files/embed_8h",version:"current",sidebar:"Reference",previous:{title:"sleepy_discord/embed.cpp",permalink:"/sleepy-discord/docs/reference/Files/embed_8cpp"},next:{title:"sleepy_discord/endpoints.cpp",permalink:"/sleepy-discord/docs/reference/Files/endpoints_8cpp"}},i=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Source code",id:"source-code",children:[]}],c={toc:i};function l(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(s.b)("wrapper",Object(r.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("h2",{id:"namespaces"},"Namespaces"),Object(s.b)("table",null,Object(s.b)("thead",{parentName:"table"},Object(s.b)("tr",{parentName:"thead"},Object(s.b)("th",{parentName:"tr",align:null},"Name"))),Object(s.b)("tbody",{parentName:"table"},Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),Object(s.b)("h2",{id:"classes"},"Classes"),Object(s.b)("table",null,Object(s.b)("thead",{parentName:"table"},Object(s.b)("tr",{parentName:"thead"},Object(s.b)("th",{parentName:"tr",align:null}),Object(s.b)("th",{parentName:"tr",align:null},"Name"))),Object(s.b)("tbody",{parentName:"table"},Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_thumbnail"},"SleepyDiscord::EmbedThumbnail")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_video"},"SleepyDiscord::EmbedVideo")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_image"},"SleepyDiscord::EmbedImage")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_provider"},"SleepyDiscord::EmbedProvider")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_author"},"SleepyDiscord::EmbedAuthor")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_footer"},"SleepyDiscord::EmbedFooter")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_field"},"SleepyDiscord::EmbedField")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed"},"SleepyDiscord::Embed")))))),Object(s.b)("h2",{id:"source-code"},"Source code"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <string>\n#include "discord_object_interface.h"\n\nnamespace SleepyDiscord {\n    struct SendMessageParams;\n\n    struct EmbedThumbnail : public DiscordObject {\n    public:\n        EmbedThumbnail() = default;\n        //EmbedThumbnail(const std::string * rawJSON);\n        EmbedThumbnail(const json::Value & json);\n        EmbedThumbnail(const nonstd::string_view & json) :\n            EmbedThumbnail(json::fromJSON<EmbedThumbnail>(json)) {\n        }\n        //EmbedThumbnail(const json::Values values);\n        std::string url;\n        std::string proxyUrl;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty();\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedThumbnail::url     , "url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::proxyUrl, "proxy_url", json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::height  , "height"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::width   , "width"    , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedVideo : public DiscordObject {\n    public:\n        EmbedVideo() = default;\n        EmbedVideo(const json::Value & json);\n        EmbedVideo(const nonstd::string_view & json) :\n            EmbedVideo(json::fromJSON<EmbedVideo>(json)) {\n        }\n        std::string url;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedVideo::url   , "url"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedVideo::height, "height", json::OPTIONAL_FIELD),\n                json::pair(&EmbedVideo::width , "width" , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n\n    struct EmbedImage : public DiscordObject {\n    public:\n        EmbedImage() = default;\n        EmbedImage(const json::Value & json);\n        EmbedImage(const nonstd::string_view & json) :\n            EmbedImage(json::fromJSON<EmbedImage>(json)) {\n        }\n        std::string url;\n        std::string proxyUrl;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty() && proxyUrl.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedImage::url     , "url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::proxyUrl, "proxy_url", json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::height  , "height"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::width   , "width"    , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedProvider : public DiscordObject {\n    public:\n        EmbedProvider() = default;\n        //EmbedProvider(const std::string * rawJSON);\n        EmbedProvider(const json::Value & json);\n        EmbedProvider(const nonstd::string_view & json) :\n            EmbedProvider(json::fromJSON<EmbedProvider>(json)) {\n        }\n        //EmbedProvider(const json::Values values);\n        std::string name;\n        std::string url;\n\n        bool empty() const {\n            return name.empty() && url.empty();\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedProvider::name, "name", json::OPTIONAL_FIELD),\n                json::pair(&EmbedProvider::url , "url" , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedAuthor : public DiscordObject {\n    public:\n        EmbedAuthor() = default;\n        EmbedAuthor(const json::Value & json);\n        EmbedAuthor(const nonstd::string_view & json) :\n            EmbedAuthor(json::fromJSON<EmbedAuthor>(json)) {\n        }\n        std::string name;\n        std::string url;\n        std::string iconUrl;\n        std::string proxyIconUrl;\n\n        bool empty() const {\n            return name.empty() && url.empty() && iconUrl.empty() && proxyIconUrl.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedAuthor::name        , "name"          , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::url         , "url"           , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::iconUrl     , "icon_url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::proxyIconUrl, "proxy_icon_url", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedFooter : public DiscordObject {\n    public:\n        EmbedFooter() = default;\n        EmbedFooter(const json::Value & json);\n        EmbedFooter(const nonstd::string_view & json) :\n            EmbedFooter(json::fromJSON<EmbedFooter>(json)) {\n        }\n        std::string text;\n        std::string iconUrl;\n        std::string proxyIconUrl;\n\n        bool empty() const {\n            return text.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedFooter::text        , "text"          , json::REQUIRIED_FIELD),\n                json::pair(&EmbedFooter::iconUrl     , "icon_url"      , json::OPTIONAL_FIELD ),\n                json::pair(&EmbedFooter::proxyIconUrl, "proxy_icon_url", json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedField : public DiscordObject {\n    public:\n        EmbedField() = default;\n        EmbedField(const json::Value & json);\n        EmbedField(const nonstd::string_view & json) :\n            EmbedField(json::fromJSON<EmbedField>(json)) {}\n        EmbedField(std::string _name, std::string _value, bool _isInline = false)\n            : name(_name), value(_value), isInline(_isInline) {}\n        std::string name = "";\n        std::string value = "";\n        bool isInline = false;\n\n        bool empty() const {\n            return value.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedField::name    , "name"  , json::OPTIONAL_FIELD),\n                json::pair(&EmbedField::value   , "value" , json::OPTIONAL_FIELD),\n                json::pair(&EmbedField::isInline, "inline", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct Embed : public DiscordObject {\n    public:\n        Embed() = default;\n        //Embed(const std::string * rawJSON);\n        Embed(const json::Value & json);\n        Embed(const nonstd::string_view & json) :\n            Embed(json::fromJSON<Embed>(json)) {}\n        //Embed(const json::Values values);\n        enum class Flag {\n            INVALID_EMBED = 0,\n            VALID_EMBED = 1\n        };\n        Embed(const Flag f) : flags(f) {}\n        std::string title;\n        std::string type;\n        std::string description;\n        std::string url;\n        std::string timestamp;\n        int32_t color = -1;\n        EmbedFooter footer;\n        EmbedImage image;\n        EmbedThumbnail thumbnail;\n        EmbedVideo video;\n        EmbedProvider provider;\n        EmbedAuthor author;\n        std::vector<EmbedField> fields;\n\n        bool empty() const {\n            return (flags == Flag::INVALID_EMBED) || (title.empty() && description.empty() && url.empty() &&\n                color == -1 && footer.empty() && image.empty() && thumbnail.empty() && video.empty() &&\n                provider.empty() && author.empty() && fields.empty());\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Embed::title      , "title"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::type       , "type"       , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::description, "description", json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::url        , "url"        , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::timestamp  , "timestamp"  , json::OPTIONAL_FIELD),\n                json::pair<-1                       >(&Embed::color      , "color"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::footer     , "footer"     , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::image      , "image"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::thumbnail  , "thumbnail"  , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::video      , "video"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::provider   , "provider"   , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::author     , "author"     , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Embed::fields     , "fields"     , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n    private:\n        friend BaseDiscordClient;\n        friend SendMessageParams;\n\n        Flag flags = Flag::VALID_EMBED;\n    };\n}\n')),Object(s.b)("hr",null),Object(s.b)("p",null,"Updated on 26 November 2021 at 18:07:04 UTC"))}l.isMDXComponent=!0},393:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return u}));var r=t(0),o=t.n(r);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=o.a.createContext({}),l=function(e){var n=o.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):d(d({},n),e)),t},b=function(e){var n=l(e.components);return o.a.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},p=o.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,a=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),b=l(t),p=r,u=b["".concat(a,".").concat(p)]||b[p]||m[p]||s;return t?o.a.createElement(u,d(d({ref:n},c),{},{components:t})):o.a.createElement(u,d({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,a=new Array(s);a[0]=p;var d={};for(var i in n)hasOwnProperty.call(n,i)&&(d[i]=n[i]);d.originalType=e,d.mdxType="string"==typeof e?e:r,a[1]=d;for(var c=2;c<s;c++)a[c]=t[c];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);